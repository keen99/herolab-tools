<!-- version 306 -->

<!DOCTYPE html>
    <style>
@media print {
  /* THIS causes our columns to flow properly from page to page*/
  /* set page size and margins */
  @page {
    size: letter;
    margin: 1.5cm;
  }
}


.elementpath {
  font-weight: lighter;
  font-size: 20%;
  float: right;
  display: inline-block
}
.name {
  font-weight: bold;
  display: inline-block;
}
.description-block {
  /*white-space: pre-wrap;*/
  white-space: pre-wrap !important; /* The pre-wrap value preserves newlines and whitespace characters, while allowing text to wrap to the next line. You can use this property to achieve a similar effect to the <pre> element, without actually using the <pre> element in your HTML. */
  word-break: keep-all; /* to allow the text to break in between words if the text is too long. */
  font-size: 80%;
  /* match the <pre> style*/
  font-family: monospace;
  /*font-size: 14px;*/
  line-height: 1.5;
  color: #333;
}


/* Style the header */
.page-header {
  /*position: absolute;*/
  /*top: 0;*/
  text-align: center;
  /*display: block;*/
  /*font-size: 20px;*/
  /*margin-bottom: 20px;*/
}
/* Style the footer */
.page-footer {
  /*position: absolute;*/
  /*bottom: 0;*/
  text-align: center;
  /*display: block;*/
  /*font-size: 12px;*/
  /*margin-top: 20px;*/
}

.main-container {
    /*position: relative;*/
    min-height:100%;
    display: flex;
    flex-direction: column;
}
.main-container-flex {
    display: flex;
    flex-direction: column;
    min-height: 100%;
}

.grid-container {
    flex: 1; /* This will make grid-container take the remaining space after header and footer */
    column-count: 2; /* creates two columns */
    column-gap: 10px; /* adds some space between columns */
    width: 80%; /* adjust as needed */
    margin: 0 auto; /* center the columns */
    margin: auto; /* center the columns */
}

@media screen and (max-width: 600px) {
  .grid-container {
    column-count: 1; /* 1 column for screen widths less than 600px */
  }
}

.grid-item {

}
.separator {
  border-top: 1px solid gray; /* adds a top border */
  margin: 10px 0; /* adds some margin */
}
    </style>
<html>
  <head>
  <body>
    <p id="status">Upload a Herolab XML file to begin processing - print to PDF to save</p>
    <input type="file" id="xml-file" accept="application/xml, text/xml, .xml" onchange="processFile()">
    <script>
    document.addEventListener("DOMContentLoaded", function() {
      document.getElementById("xml-file").onchange = processFile;
    });

function removeElements() {
  var fileInput = document.getElementById("xml-file");
  fileInput.parentNode.removeChild(fileInput);
  var status = document.getElementById("status");
  status.parentNode.removeChild(status);
}





function createHeaderAndFooter(xmlDoc) {
  // extract character name
  var characterName = xmlDoc.querySelector("character").getAttribute("name");
  // extract race name
  var raceName = xmlDoc.querySelector("race").getAttribute("name");
  // extract template names and levels
  var templateNodes = xmlDoc.querySelectorAll("templates");
  // var templateNames = [];
  // var templateLevels = [];
  for (var i = 0; i < templateNodes.length; i++) {
    var template = templateNodes[i];
    var templateSummary = template.getAttribute("summary");
    // var parts = summary.split(" ");
    // templateNames.push(parts[0]);
    // templateLevels.push(parts[1]);
  }
  // extract class names and levels
  // var classNodes = xmlDoc.querySelectorAll("class");
  var classNodes = xmlDoc.querySelectorAll("classes");
  // var classNames = [];
  // var classLevels = [];
  for (var i = 0; i < classNodes.length; i++) {
    var classNode = classNodes[i];
    var classSummary = classNode.getAttribute("summary");
    // var name = classNode.getAttribute("name");
    // var level = classNode.getAttribute("level");
    // classNames.push(name);
    // classLevels.push(level);
  }

  // Select the existing header element
  var header = document.querySelector(".main-container .page-header");

  header.classList.add("page-header");
  header.innerHTML = "" + characterName + " -- " + raceName +
    " " + templateSummary + " " + classSummary;

  // Select the existing footer element
  var footer = document.querySelector(".main-container .page-footer");
  footer.classList.add("page-footer");
  footer.innerHTML = "Footer....: ";

  // Select the existing main-container element
  var higherLevelContainer = document.querySelector(".main-container");
  higherLevelContainer.classList.add("main-container");

  // Select the existing grid-container element
  var gridContainer = document.querySelector(".main-container .grid-container")
  // Append gridContainer, header and footer to the main container
  // be sure these are in the right order.  out of order will change the DOM
  higherLevelContainer.appendChild(header);
  higherLevelContainer.appendChild(gridContainer);
  higherLevelContainer.appendChild(footer);

  // Append the main container to the body
  document.body.appendChild(higherLevelContainer);
}


function processFile() {
  // Get the file input element
  var fileInput = document.getElementById("xml-file");
  // Get the selected file
  var file = fileInput.files[0];
  // Update the status message
  document.getElementById("status").innerHTML = "Processing file: " + file.name;

  // Create a new FileReader
  var reader = new FileReader();
  // Add an event listener to be notified when the file has been read
  reader.addEventListener("load", function () {
    // Parse the file contents as XML
    var parser = new DOMParser();
    var xmlDoc = parser.parseFromString(reader.result, "text/xml");

    // createHeaderAndFooter(xmlDoc);
    // Get the grid container created earlier
    // var gridContainer = document.querySelector(".grid-container");
    var gridContainer = document.querySelector(".main-container .grid-container")

    //Variable to hold found elements
    var elements = new Set();
    //Find all elements with 'description'
    var descriptionElements = xmlDoc.getElementsByTagName('description');
    for (var i = 0; i < descriptionElements.length; i++) {
      var path = getElementXPath(descriptionElements[i]);
      console.log(path)
      path = path.replace('/document/public/character', './');
      path = path.replace('/description', '');
      path = path.replace(/\[[0-9]+\]/g, '');
      console.log(path)
      elements.add(path)
    } // end for
    // convert the set to an array
    var elements = [...elements];
    // skip these if we find them.
    // cant do ITEM level exceptions yet
    var exceptions = {
      ".//personal": true,
      ".//journals/journal": true,
      ".//skills/skill": true,
      ".//spellsmemorized/spell": true,
    };

    var exceptionNames = {
      "Additional Traits": true,
      "Spell, Touch": true,
      "Unarmed Strike": true,
      "Natural Armor": true,
      "Rations, trail (per day)": true,
      "Spell component pouch": true,
      "Waterskin": true,
      "Aura (Ex)": true,
      "Spell, Ranged": true,
      "Subtype - Human": true,
      "Type - Humanoid": true,
      "Bolts, Crossbow": true,
      "Darkvision (60 feet)": true,
      "Armor Proficiency (Heavy)": true,
      "Armor Proficiency (Light)": true,
      "Armor Proficiency (Medium)": true,
      "Martial Weapon Proficiency - All": true,
      "Shield Proficiency": true,
      "Simple Weapon Proficiency - All": true,
      "Tower Shield Proficiency": true,
      "Bedroll": true,
      "Backpack (empty)": true,
      "Item of Renown": true,
    };


    // create a set to store name + description combinations
    var seenCombinations = new Set();
    // Iterate through the elements and extract the data
    for (var i = 0; i < elements.length; i++) {
      // skip processing the entire element if it's in the exceptios list
      if (!exceptions.hasOwnProperty(elements[i]) || !exceptions[elements[i]]) {
        // code to add element to sheet
        var items = xmlDoc.evaluate(elements[i], xmlDoc, null, XPathResult.ANY_TYPE, null);
        var item = items.iterateNext();
        while (item) {
          try {
            console.log("element: " + elements[i] + " item: " + item)
            var name = item.getAttribute("name");
            if (exceptionNames.hasOwnProperty(name)) {
              // console.log("NOT Skipping exceptionNames: " + name)
              throw new Error("Skipping exceptionNames: " + name);
            } // end if exceptionName
            var descriptions = item.getElementsByTagName("description");
            if (descriptions.length === 0) {
              throw new Error("No description tag found for element " + elements[i]);
            } // end if desc.length
            var description = descriptions[0].textContent;
            var combination = name + description;
            if(seenCombinations.has(combination)) {
                console.log("duplicate name + description combination found: " + name);
            } else {
                seenCombinations.add(combination);
                // Create a new container element
                var container = document.createElement("div");
                container.classList.add("grid-item", "container");
                // Create a name element
                var nameEl = document.createElement("div");
                nameEl.classList.add("grid-item", "name");
                nameEl.innerHTML = name;
                var elEl = document.createElement("div");
                elEl.classList.add("grid-item", "elementpath");
                elEl.innerHTML = elements[i];
                // Create a description element
                var descEl = document.createElement("div");
                descEl.classList.add("grid-item", "description-block");
                descEl.innerHTML = description;
                // Append the name and description elements to the container
                container.appendChild(nameEl);
                container.appendChild(elEl);
                container.appendChild(descEl);
                // Create a separator element
                var separator = document.createElement("div");
                separator.classList.add("separator");
                container.appendChild(separator);
                // Append the container to the grid container
                gridContainer.appendChild(container);
            } // end if seenCombo/else
            } catch (error) {
              console.log("WARN: ", error);
          } // end try/catch
          // console.log("moving to next item");
          // Move to the next item
          item = items.iterateNext();
        } //end of while (item)
      } // end if exceptions
    } //end of  for (var i = 0; i < elements.length; i++)
  createHeaderAndFooter(xmlDoc);
  }); //end of reader.addEventListener("load", function ()
  reader.readAsText(file);
  removeElements();
} //end of processFile
function getElementXPath(element) {
  if (element && element.id)
    return '//*[@id="' + element.id + '"]';
  else
    return getElementTreeXPath(element);
}

function getElementTreeXPath(element) {
  var paths = [];
  // Use nodeName (instead of localName) so namespace prefix is included (if any).
  for (; element && element.nodeType == Node.ELEMENT_NODE; element = element.parentNode) {
    var index = 0;
    for (var sibling = element.previousSibling; sibling; sibling = sibling.previousSibling) {
      // Ignore document type declaration.
      if (sibling.nodeType == Node.DOCUMENT_TYPE_NODE)
        continue;
      if (sibling.nodeName == element.nodeName)
        ++index;
    }
    var tagName = element.nodeName.toLowerCase();
    var pathIndex = (index ? "[" + (index + 1) + "]" : "");
    paths.splice(0, 0, tagName + pathIndex);
  }
  return paths.length ? "/" + paths.join("/") : null;
}
   </script>
  </head>
  <body>
<!-- <div class="main-container"> -->
<div class="main-container main-container-flex">
    <div class="page-header"></div>
    <div class="grid-container">
      <div class="grid-item name"></div>
      <div class="grid-item description-block"></div>
    </div>
    <div class="page-footer"></div>
</div>


  </body>
</html>

<!-- // END OF FILE -->
